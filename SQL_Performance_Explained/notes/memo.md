# 第1章
- インデックスについての章
- 独自のディスク領域にインデックスは作成される
- インデックスにはテーブルのデータを保持する
  - つまり、純粋に冗長な構造
- データベースは双方向連結リストと検索木を組み合わせてインデックスを作成する
- インデックスリーフノード
  - リーフノードは「データベースブロック」や「ページ」と呼ばれる、データベースの最小の格納単位に保存される
  - インデックスの順序には2段階ある
    - 双方向連結リストで繋がっているリーフノード間の順序
    - リーフノード内に保存されたエントリ間の順序
- 検索木
  - バランス木なので、Bツリーと呼ばれる
  - 木の深さを同じに保つため、insert 時にはオーバーヘッドが生じる
    - 木の回転が必要になる場合がある
  - 数百万レコードのインデックスの深さは4か5ぐらいらしい
    - 6になることはめったにないそうだ
- 遅いインデックス
  - リーフノードに重複するエントリがある場合、次のリーフノードを確認する必要が生じて遅くなる場合がある？
  - たくさんのテーブルへのアクセスがあると遅い

# 第2章
## 等価演算子
- `where` 句についての章
  - クエリを遅くする一番の原因は、出来の悪い `where` 句
- プライマリキー
  - プライマリキーにはインデックスが自動で作成される
  - プライマリキー制約により一意であることが保証されるため、検索は非常に高速
- 複合インデックス
  - 複合インデックスのすべての列を指定した、完全なプライマリキーによる検索は、非常に高速
  - 複合インデックスの最初の列のみを指定すると、少し遅い
    - `RANGE SCAN` になる
  - 複合インデックスの最初の列以外を指定すると、とても遅い
    - `FULL SCAN` になる
  - 遅くなるのは複合インデックスの構造によるもの
    - ツリー内では複合インデックスに指定された順にソートされる
    - 最初の列のみを指定する場合、ある範囲にまとまって2列目以降を探せる
    - 最初の列を指定しない場合、バラバラになったものを探すことになるため、フルスキャンが必要になってしまい、遅い
  - 複合インデックスは指定する順序が重要
- インデックスを使っても遅くなる場合がある
  - `RANGE SCAN` で検索する範囲が広く、1行ずつ読み込んで比較する必要があるような場合
  - フルスキャンするほうが早い可能性がある

## 関数
- `last_name` というカラムに対してインデックスを張ったとしても、`UPPER(last_name) = UPPER('winand')` のようなクエリにはインデックスは効かない
  - オプティマイザにとってはブラックボックス
  - `UPPER(last_name)` に対してインデックスを張る必要がある
  - このように、関数や式を含むインデックスを「関数インデックス」というらしい
- 実は MySQL には関数インデックスは無いらしい
  - 代わりに Generated Columns というものがあるらしい
    - https://dev.mysql.com/doc/refman/8.0/ja/create-table-generated-columns.html
    - カラムとして計算結果を保持しておける？
  - この列に対してインデックスを張ればよい
- 与えられたパラメータに対して、結果が一意に定まるような関数でないとインデックスは作成できない
  - 乱数発生器や環境変数依存の関数なども、インデックスは作成できない
- インデックスの作りすぎに注意
  - `insert`, `update`, `delete` の度にインデックスの更新が必要なため、インデックスが多いと遅くなる

## パラメータ化クエリ
- バインドパラメータ
  - 値を SQL 文に直接埋め込まず、 `?` や `:name` などのプレースホルダを使って値を埋める
- バインドパラメータを使うと、オプティマイザは真に最適な実行計画を作ることができない
  - オプティマイザはバインドパラメータの中身を知らないため
- だが、たいていの場合においてはバインドパラメータを使えば良さそう
  - 間違いなく実行計画に影響を与えると分かっているもの以外全部

## 範囲検索
- `RANGE SCAN` でパフォーマンスへの影響が最も大きいのは、リーフノードの走査
  - パフォーマンスを高めるには、インデックスをスキャンする範囲をなるべく小さくするのが良い
- アクセス述語とフィルタ述語
  - アクセス述語は、インデックスのスキャン範囲を定義する
  - フィルタ述語は、リーフノードの走査時に適用される
- `LIKE` に対するインデックス
  - パフォーマンス的に有効なのは最初のワイルドカードの前まで
  - ワイルドカード以降はフィルタ述語となる
- 複数のインデックスを使うのはそれなりに重い処理？
  - それぞれのインデックスツリーを辿る必要がある
  - 中間結果をまとめるために CPU とメモリを消費する

## 部分インデックス
- 一部の行に対してのみインデックスを張ることができる
- インデックスを作成する際に、 `where` で条件を指定する
  - 条件を満たす行のみインデックスが作成される
- ほとんど検索されない行が大量に存在するような場合に有効
  - キューのシステムにおける処理済みの行など

## Oracle における NULL
- Oracle では空文字列を NULL として扱う
- 文字列と NULL を連結する際は NULL が空文字列として扱われる
- 列のすべてが NULL である場合、その行はインデックスに含まれない

## 処理しにくい条件
### 日付型
- 以下のような書き方はよくない
- 関数を使うとインデックスが効かない
  - MySQL には関数インデックスがない

```SQL
SELECT ...
FROM sales
WHERE DATE_FORMAT(sale_date, "%Y-%M") = DATE_FORMAT(now(), "%Y-%M")
```

- 代替案として、範囲条件を明確にするとよい
  - インデックスが効くようになる
- 検索するのが1日だけであったとしても、範囲条件にするのが良い

```SQL
SELECT ...
FROM sales
WHERE sale_date BETWEEN quarter_begin(?) AND quarter_end(?)
```

- `quarter_begin` と `quarter_end` は自分で定義する
- テーブル列を変換するのではなく、検索語の方を変換するのが良い

```SQL
-- BAD
SELECT ...
FROM sales
WHERE TO_CHAR(sale_date, 'YYYY-MM-DD') = '1970-01-01'

-- GOOD
SELECT ...
FROM sales
WHERE sale_date = TO_DATE('1970-01-01', 'YYYY-MM-DD')
```

### 数値文字列
- テキストの列に保存されている数値
- そもそも数値は数値型で保存しよう
- 日付型の例と同じく、テーブルの列はそのままで、右辺を関数に通すのがよい？

### 列の連結
- 日付と時刻が別の列にある場合など
  - 普通にやるとインデックスが効かない
  - 日付だけでもインデックスが効くように書くとマシ
- 逆に `LIKE` のある列を連結させてインデックスが効かないようにする使い方もある？

### スマートなロジック
- 動的なクエリには素直に動的な SQL を書くのが良い
  - 「動的 SQL は遅い」という都市伝説があるらしい？
  - 無理に静的なクエリを作ろうとしても遅い
- KISS 原則、大事

### 数式
- 列に対して計算をするようなクエリに対してはインデックスが効かない

```SQL
-- インデックスが効かない例
SELECT numeric_number
FROM table_name
WHERE numeric_number - 1000 > ?

SELECT numeric_number
FROM table_name
WHERE 3*a + 5 = b
```

- これを逆手に取って、0を足すことでインデックスを効かなくすることもできる
- 上手く計算式を作れば、関数インデックスを使うこともできる
  - テーブルへの参照を左辺に寄せる
  - 左辺の式に対するインデックスを作る

# 第3章
- スケーラビリティの話

## データ量がパフォーマンスに与える影響
- 当然だが、データ量が増えるとクエリは遅くなる
- ただ、インデックスの作り方によって、遅くなり具合は変わる
- インデックスをスキャンする範囲が広いと遅くなる
- 実行計画の述語情報を確認するのが大事

## システム負荷がパフォーマンスに与える影響
- 並列で動くクエリが多くなるほど遅くなる

## 応答時間とスループット
- 高価なハードウェアを使ったからといって、応答時間が短くなるとは限らない
  - CPU 性能は伸び悩んでいる
  - タスク1つの処理時間が短くなるわけでもない
- 適切にインデックスを作成するのが大事
- 本番環境でこそ遅くなる可能性がある
  - 開発環境よりも構成が複雑
  - システム間の通信などでレイテンシが増えやすい
- HDD はやっぱり遅い
  - 複数のテーブルを結合するときに遅くなりやすい？

# 第4章
- 結合の話
- 結合の順序はパフォーマンスに影響を与える
  - オプティマイザはすべての結合順序のパターンを評価し、最適なものを選択する
  - 複雑な文を最適化することは、パフォーマンス問題に繋がる可能性がある
  - バインドパラメータを使うとこの影響は受けないらしい

## 入れ子ループ
- 入れ子になったクエリを使うような動作
  - 1つ目のクエリがあるテーブルから結果を取り出し、2つ目のクエリがその結果の各行に対して、別のテーブルからデータを取り出す
- 入れ子の select は安直な方法
  - N+1 問題を引き起こす
- eager fetch をするとよい？
  - eager fetch を設定したテーブルにアクセスした際、常に指定したテーブルと結合する
  - 結合が常には必要ない場合に使うと逆効果

## ハッシュ結合
- そもそもハッシュ結合とは
  - テーブルを結合する際に、結合元のテーブルの値をもとにハッシュテーブルを作成し、それを使って結合する方法
- ハッシュ結合のパフォーマンスを最適化するには、ハッシュテーブルのサイズを小さくするのが有効
  - 条件を絞り、必要な行のみを取得するようにしたり
  - SELECT で必要な列のみを選択するようにしたり
  - するとよい

## ソートマージ結合
- ソート済みのリストで結合
- ソートの処理が重いため、あまり使われないらしい

# 第5章
- データのクラスタリングについての話
- 2種類のクラスタリング
  - コンピュータの集合である「コンピュータクラスタ」
  - 連続的にアクセスされるデータを近くに保存しておく「データクラスタ」
  - 本書では後者についての話をしている

## フィルタ述語の意図的な使用
- データが複数のブロックに分散していると、データの取得に時間がかかる
- インデックスの列を追加することで、データが近くに保存されるようになる？
- フィルタ述語に使うだけの目的では、新しいインデックスは作らないほうが良いらしい
  - 代わりに、すでにあるインデックスを拡張する

## インデックスのみのスキャン
- SELECT に含まれる列も含み、すべての列をインデックスに含めると、テーブルにアクセスする必要がなくなる
  - クエリ全体をカバーするようなインデックスを、「カバリングインデックス」というらしい
- WHERE で条件を追加してしまうと、選択される行は減るにもかかわらず、遅くなってしまう可能性がある
  - テーブルアクセスが発生するようになってしまうため

## 索引構成表
- いくつかのデータベースにおいては、一時的なテーブルの保存先としてインデックスを使えるらしい
  - Oracle では「索引構成表（IOT）」と、その他データベースでは「クラスタ化インデックス」と、それぞれ呼ぶらしい
- 索引構成表は、ヒープテーブルを持たない B ツリーインデックス
- インデックスが複数ある場合、索引構成表は不利

# 第6章
- ソートについての話

## インデックスを使った order by
- インデックスですでにソートされている場合は、 `ORDER BY` によるソートは起こらない
- 参照される範囲のみがソートされていればよい

## ASC, DESC と NULLS FIRST/LAST
- インデックスは逆順にも読める
  - リーフノードは双方向連結リストで繋がっているため
- `ASC` と `DESC` が混在していると、そのままではインデックスによるソートを使えない
  - インデックス作成時に `ASC` や `DESC` を指定するとよい
- NULL に対するソート順は不定？
  - SQL のオプション拡張として `NULLS FIRST` と `NULLS LAST` という修飾子があるらしいが、サポートは不十分
  - PostgreSQL では使えるとか

## インデックスを使った group by
- group by のアルゴリズムは2つ
  - ハッシュアルゴリズム
    - 入力されたレコードを一時的なハッシュテーブル上でまとめる
  - ソート・グループアルゴリズム
    - グループキーでソートし、各グループを順に処理
- ソート・グループアルゴリズムのソート部分において、インデックスが使える

# 第7章
- 部分結果についての話

## 最初の N 行のみの選択
- 先頭の10件だけ欲しい、みたいなとき
- 普通に `LIMIT` 句を使う
  - 実は `LIMIT` は SQL 標準ではない
- `FETCH FIRST` という書き方もある
  - これは SQL 標準
- これらの書き方で効率的に動かすには、 `ORDER BY` 句がインデックスでカバーされている必要がある

## 次ページの取得
- 前のページをどのようにスキップするか
- 2つの方法
  - オフセット法
    - `OFFSET` を使って行を捨てる
    - シンプル
    - 新しいページが挿入されるとページがずれてしまう
    - 後ろのページに行くほど応答時間が長くなる
  - シーク法
    - 各ページの最後のレコードの1つ後のレコードを検索する
    - 並べ替えの順序が確定的である必要がある
      - 一意なキーを使う

## ページネーションのための窓関数の使用
- 一部のデータベースでのみ効率的に使える
- 窓関数は数値解析に強みがあるらしい
- 窓関数、ちゃんと知っておきたいか

# 第8章
- `INSERT`, `DELETE`, `UPDATE` についての話
- インデックスは純粋に冗長なデータ
- 書き込み処理の際は、インデックスも修正する必要がある

## 挿入
- テーブルにデータを挿入するだけなら非常に高速
- インデックスの修正にかかる処理が割と重い
  - インデックスの順序の維持やツリーのバランスの維持などの処理
  - それぞれのインデックスに対して行う必要があるため、インデックスの数だけ応答時間が長くなる
- 無駄なインデックスをなるべく作らないことが大事
- 巨大なデータをロードする際に一時的に全てのインデックスを削除するのは良いやり方らしい

## 削除
- `WHERE` 句が使えるので、インデックスの恩恵にあずかることができる
- 大量の行を削除するときは、インデックスはなくても良いかもしれない
  - 広い範囲をインデックスでスキャンするより、フルテーブルスキャンの方が早い？
- 全業を削除するなら `TRUNCATE TABLE` の方が良い

## 更新
- `DELETE` + `INSERT` をするようなもの
- 必要な列のみを更新することができるため、インデックスの修正は必要最低限で済む
- 無駄に全列を更新しないように注意が必要
  - 特に ORM ツール
  - クエリをロギングして、時々確認したほうが良い
