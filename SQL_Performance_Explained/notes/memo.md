# 第1章
- インデックスについての章
- 独自のディスク領域にインデックスは作成される
- インデックスにはテーブルのデータを保持する
  - つまり、純粋に冗長な構造
- データベースは双方向連結リストと検索木を組み合わせてインデックスを作成する
- インデックスリーフノード
  - リーフノードは「データベースブロック」や「ページ」と呼ばれる、データベースの最小の格納単位に保存される
  - インデックスの順序には2段階ある
    - 双方向連結リストで繋がっているリーフノード間の順序
    - リーフノード内に保存されたエントリ間の順序
- 検索木
  - バランス木なので、Bツリーと呼ばれる
  - 木の深さを同じに保つため、insert 時にはオーバーヘッドが生じる
    - 木の回転が必要になる場合がある
  - 数百万レコードのインデックスの深さは4か5ぐらいらしい
    - 6になることはめったにないそうだ
- 遅いインデックス
  - リーフノードに重複するエントリがある場合、次のリーフノードを確認する必要が生じて遅くなる場合がある？
  - たくさんのテーブルへのアクセスがあると遅い

# 第2章
## 等価演算子
- `where` 句についての章
  - クエリを遅くする一番の原因は、出来の悪い `where` 句
- プライマリキー
  - プライマリキーにはインデックスが自動で作成される
  - プライマリキー制約により一意であることが保証されるため、検索は非常に高速
- 複合インデックス
  - 複合インデックスのすべての列を指定した、完全なプライマリキーによる検索は、非常に高速
  - 複合インデックスの最初の列のみを指定すると、少し遅い
    - `RANGE SCAN` になる
  - 複合インデックスの最初の列以外を指定すると、とても遅い
    - `FULL SCAN` になる
  - 遅くなるのは複合インデックスの構造によるもの
    - ツリー内では複合インデックスに指定された順にソートされる
    - 最初の列のみを指定する場合、ある範囲にまとまって2列目以降を探せる
    - 最初の列を指定しない場合、バラバラになったものを探すことになるため、フルスキャンが必要になってしまい、遅い
  - 複合インデックスは指定する順序が重要
- インデックスを使っても遅くなる場合がある
  - `RANGE SCAN` で検索する範囲が広く、1行ずつ読み込んで比較する必要があるような場合
  - フルスキャンするほうが早い可能性がある

## 関数
- `last_name` というカラムに対してインデックスを張ったとしても、`UPPER(last_name) = UPPER('winand')` のようなクエリにはインデックスは効かない
  - オプティマイザにとってはブラックボックス
  - `UPPER(last_name)` に対してインデックスを張る必要がある
  - このように、関数や式を含むインデックスを「関数インデックス」というらしい
- 実は MySQL には関数インデックスは無いらしい
  - 代わりに Generated Columns というものがあるらしい
    - https://dev.mysql.com/doc/refman/8.0/ja/create-table-generated-columns.html
    - カラムとして計算結果を保持しておける？
  - この列に対してインデックスを張ればよい
- 与えられたパラメータに対して、結果が一意に定まるような関数でないとインデックスは作成できない
  - 乱数発生器や環境変数依存の関数なども、インデックスは作成できない
- インデックスの作りすぎに注意
  - `insert`, `update`, `delete` の度にインデックスの更新が必要なため、インデックスが多いと遅くなる

## パラメータ化クエリ
- バインドパラメータ
  - 値を SQL 文に直接埋め込まず、 `?` や `:name` などのプレースホルダを使って値を埋める
- バインドパラメータを使うと、オプティマイザは真に最適な実行計画を作ることができない
  - オプティマイザはバインドパラメータの中身を知らないため
- だが、たいていの場合においてはバインドパラメータを使えば良さそう
  - 間違いなく実行計画に影響を与えると分かっているもの以外全部

## 範囲検索
- `RANGE SCAN` でパフォーマンスへの影響が最も大きいのは、リーフノードの走査
  - パフォーマンスを高めるには、インデックスをスキャンする範囲をなるべく小さくするのが良い
- アクセス述語とフィルタ述語
  - アクセス述語は、インデックスのスキャン範囲を定義する
  - フィルタ述語は、リーフノードの走査時に適用される
- `LIKE` に対するインデックス
  - パフォーマンス的に有効なのは最初のワイルドカードの前まで
  - ワイルドカード以降はフィルタ述語となる
- 複数のインデックスを使うのはそれなりに重い処理？
  - それぞれのインデックスツリーを辿る必要がある
  - 中間結果をまとめるために CPU とメモリを消費する

## 部分インデックス
- 一部の行に対してのみインデックスを張ることができる
- インデックスを作成する際に、 `where` で条件を指定する
  - 条件を満たす行のみインデックスが作成される
- ほとんど検索されない行が大量に存在するような場合に有効
  - キューのシステムにおける処理済みの行など

## Oracle における NULL
- Oracle では空文字列を NULL として扱う
- 文字列と NULL を連結する際は NULL が空文字列として扱われる
- 列のすべてが NULL である場合、その行はインデックスに含まれない

## 処理しにくい条件
### 日付型
- 以下のような書き方はよくない
- 関数を使うとインデックスが効かない
  - MySQL には関数インデックスがない

```SQL
SELECT ...
FROM sales
WHERE DATE_FORMAT(sale_date, "%Y-%M") = DATE_FORMAT(now(), "%Y-%M")
```

- 代替案として、範囲条件を明確にするとよい
  - インデックスが効くようになる
- 検索するのが1日だけであったとしても、範囲条件にするのが良い

```SQL
SELECT ...
FROM sales
WHERE sale_date BETWEEN quarter_begin(?) AND quarter_end(?)
```

- `quarter_begin` と `quarter_end` は自分で定義する
- テーブル列を変換するのではなく、検索語の方を変換するのが良い

```SQL
-- BAD
SELECT ...
FROM sales
WHERE TO_CHAR(sale_date, 'YYYY-MM-DD') = '1970-01-01'

-- GOOD
SELECT ...
FROM sales
WHERE sale_date = TO_DATE('1970-01-01', 'YYYY-MM-DD')
```

### 数値文字列
- テキストの列に保存されている数値
- そもそも数値は数値型で保存しよう
- 日付型の例と同じく、テーブルの列はそのままで、右辺を関数に通すのがよい？
