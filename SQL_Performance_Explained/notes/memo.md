# 第1章
- インデックスについての章
- 独自のディスク領域にインデックスは作成される
- インデックスにはテーブルのデータを保持する
  - つまり、純粋に冗長な構造
- データベースは双方向連結リストと検索木を組み合わせてインデックスを作成する
- インデックスリーフノード
  - リーフノードは「データベースブロック」や「ページ」と呼ばれる、データベースの最小の格納単位に保存される
  - インデックスの順序には2段階ある
    - 双方向連結リストで繋がっているリーフノード間の順序
    - リーフノード内に保存されたエントリ間の順序
- 検索木
  - バランス木なので、Bツリーと呼ばれる
  - 木の深さを同じに保つため、insert 時にはオーバーヘッドが生じる
    - 木の回転が必要になる場合がある
  - 数百万レコードのインデックスの深さは4か5ぐらいらしい
    - 6になることはめったにないそうだ
- 遅いインデックス
  - リーフノードに重複するエントリがある場合、次のリーフノードを確認する必要が生じて遅くなる場合がある？
  - たくさんのテーブルへのアクセスがあると遅い

# 第2章
## 等価演算子
- `where` 句についての章
  - クエリを遅くする一番の原因は、出来の悪い `where` 句
- プライマリキー
  - プライマリキーにはインデックスが自動で作成される
  - プライマリキー制約により一意であることが保証されるため、検索は非常に高速
- 複合インデックス
  - 複合インデックスのすべての列を指定した、完全なプライマリキーによる検索は、非常に高速
  - 複合インデックスの最初の列のみを指定すると、少し遅い
    - `RANGE SCAN` になる
  - 複合インデックスの最初の列以外を指定すると、とても遅い
    - `FULL SCAN` になる
  - 遅くなるのは複合インデックスの構造によるもの
    - ツリー内では複合インデックスに指定された順にソートされる
    - 最初の列のみを指定する場合、ある範囲にまとまって2列目以降を探せる
    - 最初の列を指定しない場合、バラバラになったものを探すことになるため、フルスキャンが必要になってしまい、遅い
  - 複合インデックスは指定する順序が重要
- インデックスを使っても遅くなる場合がある
  - `RANGE SCAN` で検索する範囲が広く、1行ずつ読み込んで比較する必要があるような場合
  - フルスキャンするほうが早い可能性がある
