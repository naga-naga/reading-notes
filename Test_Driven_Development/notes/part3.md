# 第3部

## 第25章
- テストファースト
  - テストがないまま実装を進めるとストレスが増加する
  - ストレスが増加するとテストを書かなくなる
  - 先にテストを書くことで、不安やストレスを無くしながら実装できる
- アサートファースト
  - テストではアサーションを最初に書くと良い
  - 実装すべきことが明確になる
  - コードもシンプルになる

## 第26章
- 既知のものから未知のものへテストを進めていくとよい
- はじめのテストは、そこから学ぶものがありそうで、かつ、すぐに書けそうなテストを書くとよい
- 学習用テスト
  - API が期待通りに動作するかを確認するためのテスト
  - 他人が書いて、自分が知らないコードを動かしたいときにやると良さそう
- 休憩は大事
  - 良いアイデアを思いつくこともある

## 第27章
- 大きなテストが失敗したら小さいテストを作る
  - レッド・グリーン・リファクタリングの流れを守るために、小さくして動かす
  - 元の失敗するテストは、消すなりスキップさせるなりしておく
- Mock Object パターン
  - 重い構築処理が必要であったり、準備に手間がかかったりするリソースに依存するオブジェクトをテストしたい場合
  - 決められた結果を返す偽物のオブジェクトを代わりに作る
  - データベースやネットワークが絡むようなテスト？
- Self Shunt パターン
  - 自己接続パターン
  - テストケースそのものをモックオブジェクトとして使う？
- Crash Test Dummy パターン
  - 衝突実験ダミー人形パターン
  - 普通は到達しないようなエラー処理のテスト
  - メソッドをモックして例外を投げる
  - 例
    - ファイル作成時に `IOException` を投げるようにオーバーライドする
- 一人でプログラミングをしている際に終わらせるのに良いタイミング
  - テストが失敗したとき
  - 再開したときに、前回何を考えていたかを思い出しやすい
    - 落ちていたテストを通す、という次の目標が明確なため
  - プログラミング以外に、執筆などにも応用ができる？
- チームでプログラミングをしている際に終わらせるのに良いタイミング
  - テストがすべて通る状態
  - チーム開発時は、前回の状態からどのように変わったのかが分からないことがよくある？
  - そのような場合には、自身と確信がある場所から再開するのが良い
- 終わらせるタイミングについての所感
  - チームの大きさや、作業の仕方によって変わりそう
  - 大規模なチームで、自分の知らない場所でコードが書かれることが多いのであれば、すべて通る状態で終わらせるのが良さそう
  - 逆に、小規模なチームで全員が作業内容を共有できているのであれば、落ちる状態で終わらせても良さそう

## 第28章
- テストの通し方
  - まずは、値をべた書きで返す仮実装
  - 慎重に一般化したいときは、テストを増やして三角測量
  - 実装が分かり切っているならそれを書く
- コレクションを扱う操作を実装する場合の流れ
  - まずは単数の時の操作を実装する
  - 次に複数要素を受けとる引数を追加
  - 追加した引数を用いて実装
  - 単体の引数を削除

## 第29章
- xUnit をどう使うか、みたいな章
- アサーション
  - 真偽値を返そう
  - 適切なアサーションメソッドを使おう
- 事前状態
  - 各テストに共通するオブジェクトは `setUp` や `before` で初期化しよう
  - 共通のものをくくりだすと、コードはシンプルになるが、テストを読み解くために他の場所を参照する必要が出てくる
  - 好みやバランスの問題？
- 事後処理
  - `tearDown` や `after` でやろう
- テストを書くときはアウトラインをまず書くとよいかもしれない
  - RSpec なら `context` や `it` を並べる感じか
- 例外のテスト
  - 期待した例外のみ握りつぶして、それ以外の場合は失敗させるという方法

## 第30章
- デザインパターンについて
- Command パターン
  - Java の `Runnable` のようなもの
  - `run` メソッドのようなメソッドを用意しておき、各実装はそれをオーバーライドする
  - シンプルなメソッド呼び出しよりも複雑になってきたときに使うとよい？
- Value Object パターン
  - オブジェクト作成時に設定した状態を決して変えないようにする
  - 何か操作をしたい場合は、新しくオブジェクトを作成して返す
  - 等価性の比較を実装する必要がある
- Null Object パターン
  - Null であることを示すような、特殊なオブジェクトを作る
  - null チェックが不要になる
- Template Method パターン
  - 抽象メソッドの並びで処理を記述し、実装はサブクラスでそれぞれ書く
  - 最初からそう設計するよりも、リファクタリングで重複を排除した結果こうなる、ということが多い？
- Pluggable Object パターン
  - バリエーションを表現するための条件分岐は増殖する
  - ポリモーフィズムで解決しよう、という感じ？
- Pluggable Selector パターン
  - 動的にメソッドを呼ぶことで、サブクラスを作らなくて済むようにするパターン
  - 濫用すると大変そう
  - 非常に単純な状態にのみ使う
- Factory Method パターン
  - コンストラクタの代わりに普通のメソッドでオブジェクトを作る
  - コンストラクタよりも柔軟
- Imposter パターン
  - ポリモーフィズムで新たなバリエーションを生み出す
  - Pluggable Object パターンとの違いがよく分からない
- Composite パターン
  - `Folder` の入った `Folder` 、`TestSuite` の入った `TestSuite` など、自身を含んだ入れ子構造を表すのに使う
- Collecting Parameter パターン
  - 結果格納用のオブジェクトを引きまわして、複数のオブジェクトの結果を集める
- Singleton パターン
  - > グローバル変数のないプログラミング言語でグローバル変数を作るにはどうすればよいだろうか――決してやってはならない。そんなことを考える時間は設計に回して、コードをきれいにしよう。
  - 基本的に使いどころはなさそうか？

## 第31章
- リファクタリングの話
- TDD ではテストによって動作が変わっていないことを保証できる
- 似たコードを完全に一致させられればまとめられる
- 小さいステップで変更していくのが良さそう？
- 1つのオブジェクトに対して2つ以上のメッセージ呼び出しが行われているのは、メソッド移動のサイン
