# 第1章
- 自動テストで大事なこと
  - 自動テストの種類によって向き・不向きがある
  - あるテストを「書くことができる」ことは、必ずしも「書くべきだ」という理由にはならない
  - 高速にテストを実行し、フィードバックを素早く得ることが大事
- テストのピラミッド
  - UI テスト
    - UI 層に対応
  - 統合テスト
    - サービス層に対応
  - ユニットテスト
    - ロジック層に対応
- 各テストの特徴
  - UI テスト
    - 利用者の視点でのテスト
    - E2E（エンドツーエンド）テスト
    - 全てがつながっていることを検証できる
    - 遅く、壊れやすい
  - 統合テスト
    - UI の変更に影響されない
    - 複数の機能の繋がりを検証できる
    - 詳細さに欠ける
  - ユニットテスト
    - 高速
    - テスト失敗時、どの部分が上手くいかなかったのかが厳密に分かる
    - 統合部分の確認には弱い
- テストに関する経験則
  - ユニットテストを優先すること
  - ユニットテストで埋められない部分を統合テストでカバーすること
  - UI テストは限定的に使うこと
  - テストは出来る限り下の層に入れるのが良い
  - 全てを自動化しようとするのではなく、過不足なく自動化する

# 第2章
- UI テストの話
- スモークテスト
  - システムが基本的なレベルで動作していることを確認する高レベルのテスト
  - 最低限動いていることを保証してくれる

# 第3章
- CSS セレクタの話
  - ID があると楽
- UI テストは緩く保つのが良い
  - 例：メッセージの存在のみをチェックし、文言まではチェックしない
  - 理由：詳細に書きすぎると、UI とテストの結合が密になりすぎ、テストが壊れやすくなるため

# 第4章
- 統合テストの話
- 複数の部品が繋がっていることを確認できる堅牢性と、十分な機動性がある
- REST について
  - リソースの名前を URL として定義し、4つの動詞で操作する

# 第5章
- RESTful な Web サービスの統合テストについて
- CRUD の各操作に対してのテストの書き方の例
  - リクエストを投げて、指定のリソースが取得、作成、更新、削除されることを確認する

# 第6章
- ユニットテストについて
- ユニットテストを書くときに考慮すべきこと
  - ハッピーパス
    - 正常系
    - 理想的な条件ではどのように動作するのか？
  - 特殊ケース
    - 特殊な条件やエッジケース
  - 例外
    - どのような条件で、どのような例外を出すのか
  - プログラムのロジックと流れ
    - すべてのパス、ロジックの流れ、条件分岐は適切に動いているか
  - その他
    - 正しく動いていると自信を持つために必要なテストは何でも
- テストが、対象のコードがどのように動くかのデモになるのが望ましい？
- カバレッジを上げることに執着する必要はない
- ユニットテストではネットワークに直接繋がない
  - 代わりに準備済みのデータを使う
- 依存性の注入
  - 確認したいオブジェクトを、テスト対象のクラスのコンストラクタで渡す
  - テスト時にモックを渡すことで、メソッド内部でオブジェクトに起こる事象を捕捉できるようになる
    - つまり、ある特定のメソッドが呼ばれたか、ということがテストできるようになる

# 第7章
- JavaScript を使ったブラウザ上のユニットテストについて
- クライアントだけで完結するユニットテストを書くこともできる
- MVC
  - Model と View は相互に直接触らない
  - 必ず Controller を介するようにする

# 第8章
- テストのピラミッドについて
  - ユニットテストから始める
    - 「壊れる可能性のあるものは全てテストする」
    - サーバ側だけでなく、フロントも
  - 統合テストについて
    - 大まかなつながりをテストする
    - リクエストに対して適切なレスポンスが返ってくるか、など
  - UI テスト
    - ある程度 UI が落ち着いてきてから追加する
    - UI テストが1件もなくともよい
    - UI テストは不安定なので、あまり深い部分には立ち入らない
- 逆ピラミッド
  - ユニットテストが少なく、UI テストが多い状態
  - アイスクリームコーンとも
  - テストの保守のコストが高い
  - なるべく下の層にテストを移していけるとよい
  - 逆ピラミッドでも、ないよりはまし
    - 自動テストのない、巨大なレガシーシステムなど
    - ユニットテストをゼロから埋め直すよりは、コスト面でリターンを得やすいらしい
- 不安定なテストに立ち向かう3つの手法
  - テストを書き直す
    - 他の方法でテストをできないか探す
  - テストを下の層に移動させる
    - 大事
  - そのテストを消す
    - そもそも価値はないとして、消して新たにテストを書く
    - Facebook ではそうしているらしい

# 第9章
- 良いコードの書き方について
- 適切な命名、適切なインデント、重複の排除をしよう、という感じ
- 特に目新しい内容はない

# 第10章
- テストの整理方法について
- 2つのテクニック
  - テストの分離
  - コンテキストによるテストの分類
- テストの分離
  - 一度にテストする内容を1つ、またはひとまとまりの概念に限る
  - シンプルで読みやすくなる
  - 1つのテストケースに1つのアサーションのみを入れるルール
    - 読みやすく、保守も容易になるが、必ずしも守らなければならないというものではない
    - 場合によって複数のアサーションを入れてもよい
    - それよりも大事なのは、1つのテストでテストする内容を1つに絞ること
  - テストに使うデータは、なるべくそれを使うテストの近くにまとめる
- コンテキストによるテストの分類
  - ユニットテストはクラスごと、統合テストはサービスやエンドポイントごと、UI テストは画面ごとに、それぞれ分けると良さそう
  - コンテキストを明示的にする
    - 「何についてのテストか」ということをクラス名などに明示的に書く
      - RSpec なら `describe` でいいかも
  - テストのまとまりごとにディレクトリを分けるというやり方も良さそう
  - テストの分類方法には複数の選択肢がある
    - UI の画面に対する分類
    - コンテキストでの分類
- テストの整理の仕方によって、その後の変更のしやすさが大きく変わる
  - 上手く整理してあげるのが大事
  - 次の2つの考え方が大事
    - 1つのテストでは1つのことをテストする。一度に多くの内容をテストしない
    - 似ているテストをコンテキストによってまとめる

# 第11章
- モックについて
- モックを使う代表的なケース
  - 外部サービスの呼び出しが高コストであったり遅かったりする場合
- モックとスタブの違い
  - スタブはハードコードされたデータを返すだけ。基本的にロジックを持たない
  - モックはデータを返すだけでなく、テストを通じて操作、監視される
- モック化のフレームワークの2種類の考え方
  - 厳密なモック化
    - テスト中に登場する全てのモックに対して、テストしたい内容かどうかにかかわらず、全ての呼び出しを明示的に記述する
    - expectation が抜けているとテストが失敗する
  - 緩やかなモック化
    - テストに記述されている expectation が満たされてさえいれば、テストは成功する
    - テストの意図が明確になる、結合度が下がりコードが壊れにくくなる、テストの保守がしやすくなるなどの理由から、現在はこちらが主流らしい
- ユニットテストは外から見た振る舞いに着目すると良さそう？
  - 内部をテストしようとすると結合度が高くなる
  - パブリック API を呼ぶだけにする
- テストしたいメソッドがプライベートメソッドである場合
  - パブリックなインタフェースを通してプライベートメソッドをテストできないか考える
  - できないなら優先してテストする必要はないらしい
