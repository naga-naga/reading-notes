## 正規表現
- `=~`
  - 正規表現でマッチさせる演算子
  - マッチすれば開始位置が返り、マッチしなければ `nil` が返る
- `!~`
  - こちらもマッチさせる演算子
  - マッチしなければ `true`
  - マッチすれば `false`
- キャプチャに名前を付ける
  - 正規表現内で `(?<name>ここに正規表現)` のように書くと、マッチした後に `:name` で参照できる
  - `=~` の左辺に正規表現リテラルを置いた場合に限り、ローカル変数として使えるようになる
    - 右辺に書いたり変数に束縛したりすると使えない
- `$1`
  - マッチした結果が入る
  - 数字に制限はない
  - `$&` で文字列全体になる
  - `$+` は最後の文字列
- 正規表現が使える `String` のメソッドたち
  - `scan`
    - `'123 456 789'.scan(/\d+/) #=> ["123", "456", "789"]`
  - `[]`, `slice`, `slice!`
    - `'123-4567'[/\d{3}/] #=> "123"`
    - `slice` は `[]` のエイリアス
    - `slice!` は元の文字列から破壊的に取り除く
  - `split`
    - `'foo,bar.baz'.split(/[,.]/) #=> ["foo", "bar", "baz"]`
  - `gsub`, `gsub!`
    - `'foo,bar.baz'.gsub(/[,.]/, '|') #=> "foo|bar|baz"`
    - 第2引数にはハッシュも書ける
      - `'foo,bar.baz'.gsub(/[,.]/, ',' => '|', '.' => '^') #=> "foo|bar^baz"`
      - 文字ごとに変換先を指定できる
    - ブロックも書ける
      - `'foo,bar.baz'.gsub(/[,.]/) { _1 == ',' ? '|' : '^' } #=> "foo|bar^baz"`
      - ブロックにすると `$1` などが使えるようになる
    - `gsub!` は破壊的
- オプション
  - `i`
    - 大文字小文字を区別しない
    - `Regexp::IGNORECASE`
  - `m`
    - `.` が改行にマッチする
    - `Regexp::MULTILINE`
  - `x`
    - 空白文字が無視され、コメントが書けるようになる
    - `Regexp::EXTENDED`

