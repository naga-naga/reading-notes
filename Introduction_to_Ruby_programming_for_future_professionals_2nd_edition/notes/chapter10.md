## yield と Proc
- ブロック
  - メソッド内で `yield` すると、引数として渡されたブロックを実行できる
  - 複数回 `yield` できる
  - `block_given?` でブロックが渡されたか確認できる
  - `yield` に引数を渡したり、ブロックの戻り値を受け取ったりできる
  - 明示的にブロックを引数に取りたい場合は、変数名の頭に `&` を付ける
    - `def foo(&block) ... end`
    - この場合は `call` でブロックを呼び出せる
    - `yield` も使える
    - 別のメソッドにブロック引数を渡したいときも `&` を付けて渡す
      - つけないと通常のメソッドと解釈されるため
      - 例: `another_method(&block)`
- Proc
  - Procedure
  - 関数オブジェクトのようなもの
  - `new` するときにブロックを渡す
  - `call` で呼び出し
  - ブロックの代わりに渡せる
    - その場合は変数名に `&` を付ける必要がある
  - 普通の引数として渡すこともできる
    - その場合は `&` は不要
  - 色々な呼び方
    - `add = Proc.new { |a, b| a + b }` に対して呼ぶ
    - `add.call(1, 2)`
    - `add.yield(3, 4)`
    - `add.(4, 5)`
    - `add[6, 9]`
    - `add === [2, 5]`
      - `case` の `when` で呼べるようにするため
  - `&` を付けるのは、実は `to_proc` を呼び出していた？
- ラムダ
  - `lambda { |a, b| a + b }`
  - `->(a, b) { a + b }`
  - ラムダの方が引数に関して厳密
