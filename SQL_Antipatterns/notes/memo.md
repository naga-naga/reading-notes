# 第1章 ジェイウォーク（信号無視）
- 多対多を表現する際に、カンマ区切りの文字列などでデータを保持してしまうアンチパターン
- 問題
  - 正規表現で値を取り出すなどの操作が必要になり、クエリを作るのが面倒になる
  - インデックスを使えずパフォーマンスが落ちる
  - 集約クエリが上手く使えない
  - 値の更新時にソート順を維持できない
  - 値の妥当性の検証ができない
    - 全部文字列で入れることになるため
  - 区切り文字をどうするのか
  - リストの長さの制限をどう決めるのか
- 解決策
  - 多対多のテーブルを繋ぐ中間テーブルを作成する
  - 上記問題が解決するほか、各エントリに属性を追加できる

# 第2章 ナイーブツリー
- ツリー構造をデータベース上で扱う場合の話
- アンチパターン
  - `parent_id` のようなカラムを持ち、親のみに依存する方法
  - 隣接リストというらしい
- 問題点
  - 単純なクエリでは2つの階層しか見ることができない
    - 「あるノードの全ての子孫を取得する」といったクエリが書けない
      - 階層の分だけ `JOIN` が必要になる
    - かといって階層の数を制限するのも苦しい
      - ツリーにするということは、大抵の場合において深さに制限はないはず
  - ノードの削除が大変
    - リーフノード以外を削除した場合に、 `parent_id` の更新が必要になる
- アンチパターンを使ってもよい場合
  - 直近の親子のみを参照し、削除も行わないような場合
  - 再帰クエリ構文がサポートされている場合
- 解決策
  - 経路列挙(Path Enumeration, Materialized Path)
    - `'1/2/3/4/` のような形で、親子関係をパスの形にする
    - 先祖や子孫の参照が容易
    - パスの文字列の上限の問題がある
      - 第1章のジェイウォークと同じ問題
  - 入れ子集合(Nested Set)
    - ツリーを深さ優先探索して、ノードの左と右にそれぞれ番号を振っていく
    - 削除が容易
    - 直近の親の取得が大変
    - ノードの挿入や移動などの操作も面倒
      - ノードの左右の数値を毎回計算する必要がある
  - 閉包テーブル(Closure Table)
    - ツリー全体の先祖・子孫の関係を保持するテーブルを作る
    - 先祖や子孫の取得が容易
    - 削除も容易
      - ただし、閉包テーブルから消しても、本体は消されないことに注意
      - 関係性を柔軟に変更できる
    - 行数が多く、スペースを消費するというトレードオフ
